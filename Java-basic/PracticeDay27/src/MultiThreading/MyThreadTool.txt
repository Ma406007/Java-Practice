线程池的核心元素:
1.核心线程数量(不能小于0)
2.线程池中最大线程的数量(最大数量 >= 核心线程数量)
3.空闲时间(值)(不能小于0)
4.空闲时间(单位)(用TimeUnit指定)
5.阻塞队列(不能为null)
6.创建线程的方式(不能为null)
7.要执行的任务过多时的解决方案(不能为null)

以下有几个实际开发中会遇到的状况:
1.假设核心线程数量为3,临时线程数量为3,待处理的任务数量为3.此时线程池就会创建三个线程,并且这三个线程只能是核心线程,轮不到临时线程来完成任务,此时提交三个任务均会由三个核心线程完成
2.假设核心线程数量为3,临时线程数量为3,待处理的任务数量为5.因为核心线程的数量小于待处理的任务数量,直观感受上线程池会直接创建五个线程来一次性地完成五个任务
  但实际上线程池依然只会创建三个线程,这三个线程都是核心线程,然后根据任务的提交顺序先处理前三个任务.剩下的两个任务并不会直接由线程池创建临时线程来完成,而是先将其放入阻塞队列
  等待核心线程空闲时才会被执行
3.假设核心线程数量为3,临时线程数量为3,待处理的任务数量为8,阻塞队列的长度为3.按照前两个情况,线程池首先会创建三个线程先处理前三个任务,随后再将三个任务放入阻塞队列中
  此时还剩下两个待处理任务,这时线程池才会调用临时线程,线程池创建了两个临时线程来处理剩下的两个任务
4.假设核心线程数量为3,临时线程数量为3,待处理的任务数量为10,阻塞队列的长度为3.同样的,线程池首先会创建三个线程先处理前三个任务,随后再将三个任务放入阻塞队列中
  随后又调用了三个临时线程,创建了三个临时线程来处理三个任务后还有一个任务等待处理.此时阻塞队列已经排满,而核心线程和临时线程都在执行各自的任务,这时会怎么处理剩下的一个任务呢
  这时就引入了线程池的任务拒绝策略,任务拒绝策略的作用就是来处理多余的还没有被执行的任务,共分为四种:
    第一种:ThreadPoolExecutor.AbortPolicy 也是线程池的默认策略,当还有多余任务还处在等待状态线程池会直接丢弃任务并抛出RejectedExecutionException异常
    第二种:ThreadPoolExecutor.DiscardPolicy 线程池会直接丢弃多余任务,但是并不会抛出异常,这是最不推荐的策略
    第三种:ThreadPoolExecutor.DiscardOldestPolicy 线程池会抛弃队列中等待最久的任务(即从队头开始),然后把当前任务加入到阻塞队列中
    第四种:ThreadPoolExecutor.CallerRunsPolicy 线程池会直接调用多余任务中的run()方法来绕过线程池直接执行

细节:
1.由第二种情况可知:线程池中处理任务会存在以下优先级:核心线程 > 阻塞队列 > 临时线程.即任务执行或存放的顺序会严格的遵从:先调用核心线程,再排满阻塞队列,最后才调用临时线程
2.由第三种情况可知:我们假设8个任务是按照顺序提交的,即任务1,任务2...任务8.首先任务1到任务3会被核心线程执行,随后任务4到任务6会被排入阻塞队列,此时任务7和任务8会被线程池调用的临时线程执行
  也就是说,任务的执行顺序可能会与任务的提交顺序不同,比如第三种情况的任务的提交顺序是1,2,3,4,5,6,7,8,而其执行顺序却是1,2,3,7,8,4,5,6
3.对于多余的任务,应该根据实际状况来选择合适的任务拒绝策略