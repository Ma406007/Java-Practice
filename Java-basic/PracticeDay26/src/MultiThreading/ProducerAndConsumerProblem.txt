生产者和消费者模式(等待唤醒机制)是一个十分经典的多线程协作的模式
其作用用来打破线程执行顺序的随机性,来实现两个以上的线程的轮流执行

实际场景理解:
假设有两个线程和一个中间件.其中一个线程是生产者,用来生产数据,这里形象化为一个吃货;另外一个是消费者,用来消费数据,这里形象化为一位厨师;还有一个中间件,作用是控制线程的执行,这里形象化为一张桌子
理想情况下,如果厨师进程在程序运行后首先抢到了CPU的执行权,厨师就会做一碗面放在桌子上.这时吃货进程抢到了CPU的执行权,就会将这碗面吃掉.随后厨师又会做一碗面,吃货又将这碗面吃掉
循环往复,每次厨师做一碗面吃货都会把这碗面吃掉,就实现了厨师进程和吃货进程的轮流执行.当然这只是理想情况

实际上总是会分为以下两种情况:
第一种是消费者等待
假设程序运行后是吃货进程首先抢到了CPU的执行权,因此桌子上并没有面条,因为厨师进程并没有执行,这时吃货进程就会进入等待(wait)状态,随后会将CPU的执行权转让给厨师进程
当厨师进程拿到CPU的执行权后,就会做一碗面条放在桌子上,因为吃货进程还处于等待状态,并不知道厨师为他做了一碗面条,这时需要厨师去提醒一下吃货来吃面条,也就是厨师进程唤醒(notify)吃货进程
其代码执行情况大致如下:
消费者的执行情况是:1.判断桌子上有没有食物 2.如果没有就会进入等待状态
生产者的执行情况是:1.生产食物 2.把食物放在桌子上 3.唤醒处于等待状态的消费者


第二种是生产者等待
假设程序运行后是厨师进程首先抢到了CPU的执行权,根据上面的代码执行情况,厨师会像往常一样做一碗面条并放在桌子上,并提醒消费者来吃.这里我们再假设在程序的第二次运行后还是厨师进程抢到了CPU的执行权
由于这时桌子上已经有了一碗面条,厨师进程并不会像往常一样再做一碗面条,这时厨师只能进入等待状态,来等待消费者来吃面
因此可以在这个基础上来完善上面的代码执行情况:
消费者的执行情况是:1.判断桌子上是否有食物 2.如果没有就等待 3.如果有就开吃 4.吃完之后,唤醒厨师继续做
生产者的执行情况是:1.判断桌子上是否有食物 2.如果有就等待 3.如果没有就制作食物 4.把食物放在桌子上并唤醒等待的消费者